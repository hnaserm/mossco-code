import yaml
import sys
import os

if len(sys.argv) > 1:
    filename = sys.argv[1]
else:
    filename = 'coupling_system.yaml'

print sys.argv, len(sys.argv)
if not os.path.exists(filename):
    print 'File ' + filename + ' does not exist.'
    exit(1)
    
print 'Using ' + filename + ' ...' 

fid = file(filename,'rU')
config = yaml.load(fid)
fid.close()

# Search for the key with name "coupling".  If part of the filename is the word "coupling" then assume that the first item on the list read is the name of the coupling
coupling_name = 'coupling'
variables = []
coupling_properties = []

if config.has_key('author'):
    author = config.pop('author')
else:
    author = 'Carsten Lemmen, <carsten.lemmen@hzg.de>'

if config.has_key('copyright'):
    copyright = config.pop('copyright')
else:
    copyright = 'Copyright (C) 2014, Helmholtz-Zentrum Geesthacht'

coupling = config.pop("coupling")

componentList=[]
intervals =[]
directions = []
couplingList=[]
couplerList=[]

for item in coupling:
    if type(item) is dict:
        if item.has_key("components"):
            couplingList.append([item["components"][0], item["components"][-1]])
            componentList.extend(item["components"])
            if item.has_key("interval"):
                intervals.append(item["interval"])
            else:
                intervals.append("60 min")
            if item.has_key("direction"):
                directions.append(item["direction"])
    else:
        print 'Warning, dictionary expcted for item ' + item

print couplingList
componentSet=set(componentList)
couplerSet=set(couplerList)

# Done parsint ghte list, now write the new toplevel_compnent file
       
outfilename = 'toplevel_coupling.F90'
fid = file(outfilename,'w')

fid.write('''
!> @brief Implementation of an ESMF toplevel coupling
!>
!> Do not edit this file, it is automatically generated by
''')
fid.write('!> the call \'python ' + sys.argv[0] + ' ' + filename + '\'')
fid.write('''
!>
!> This computer program is part of MOSSCO. 
''')
fid.write('!> @copyright ' + copyright + '\n')
fid.write('!> @author ' + author + '\n')
fid.write('''
!
! MOSSCO is free software: you can redistribute it and/or modify it under the
! terms of the GNU General Public License v3+.  MOSSCO is distributed in the
! hope that it will be useful, but WITHOUT ANY WARRANTY.  Consult the file
! LICENSE.GPL or www.gnu.org/licenses/gpl-3.0.txt for the full license terms.
!
''')

fid.write('module ' + 'toplevel_coupling\n') 
fid.write('''
  use esmf
  use mossco_variable_types
  use mossco_state\n
''')

for item in componentSet:
    fid.write('  use ' + item + '_component,\t\tonly : ' + item + '_SetServices => SetServices \n')

fid.write('\n  implicit none\n\n  private\n\n  public SetServices\n\n')

for item in couplerSet:
    fid.write('  type(ESMF_CplComp),\tsave\t:: ' + item + 'Comp\n')    
for item in componentSet:
    fid.write('  type(ESMF_GridComp),\tsave\t:: ' + item + 'Comp\n')    
for item in componentSet:
    fid.write('  type(ESMF_State),\tsave\t:: ' + item + 'ExportState, ' + item + 'ImportState\n')    

fid.write('''
    type(ESMF_Clock)     :: clock !> This component's internal clock

  contains

  !> Provide an ESMF compliant SetServices routine, which defines
  !! entry points for Init/Run/Finalize
  subroutine SetServices(gridcomp, rc)
  
    type(ESMF_GridComp)  :: gridcomp
    integer, intent(out) :: rc

    rc = ESMF_SUCCESS

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_INITIALIZE, Initialize, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_RUN, Run, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_FINALIZE, Finalize, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    rc=ESMF_SUCCESS
    
  end subroutine SetServices

  !> Initialize the coupling
  !!
  subroutine Initialize(gridComp, importState, exportState, parentClock, rc)

    implicit none

    type(ESMF_GridComp)  :: gridComp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: parentClock
    integer, intent(out) :: rc

    character(len=19)    :: timestring
    type(ESMF_Time)      :: clockTime
    type(ESMF_TimeInterval) :: timeInterval
    real(ESMF_KIND_R8)   :: dt
    integer              :: lbnd(3), ubnd(3),farray_shape(3)
    integer              :: myrank,i,j,k
 
    type(ESMF_DistGrid)  :: distgrid
    type(ESMF_Grid)      :: grid
    type(ESMF_ArraySpec) :: arrayspec
    
    ! Create a local clock, set its parameters to those of the parent clock
    clock = ESMF_ClockCreate(parentClock, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    
    call ESMF_ClockSet(clock, name=\'toplevel_coupling clock\', rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    ! Create all gridded omponents and their states
''')
for item in componentSet:
    fid.write('    ' + item + 'Comp = ESMF_GridCompCreate(name=\'' + item + 'Comp\', rc=rc)\n')
    fid.write('    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)\n')
    fid.write('    call ESMF_GridCompSetServices(' + item + 'Comp, ' + item + '_SetServices, rc=rc)\n')
    fid.write('    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)\n\n')

    fid.write('    ' + item + 'ExportState = ESMF_StateCreate(stateintent=ESMF_STATEINTENT_UNSPECIFIED,name=\'' + item + 'ExportState\')\n')
    fid.write('    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)\n')
    fid.write('    ' + item + 'ImportState = ESMF_StateCreate(stateintent=ESMF_STATEINTENT_UNSPECIFIED,name=\'' + item + 'ImportState\')\n')
    fid.write('    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)\n\n')

if len(couplerSet)>0:
    fid.write('    ! Create all coupler components')
for item in couplerSet:
    fid.write('    ' + item + 'Comp = ESMF_CplCompCreate(name=\'' + item + 'Comp\', rc=rc)')
    fid.write('    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)\n')
    fid.write('    call ESMF_CplCompSetServices(' + item + 'Comp, ' + item + '_SetServices, rc=rc)')
    fid.write('    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)\n\n')

fid.write('    ! Initialize all gridded and coupler components\n')
for item in componentSet:
    fid.write('    call ESMF_GridCompInitialize(' + item + 'Comp, importState=' + item + 'ImportState, &\n')
    fid.write('      exportState=' + item + 'ExportState, clock=parentClock, rc=rc)\n')
    fid.write('    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)\n')
fid.write('\n')
for item in couplerSet:
    fid.write('    call ESMF_CplCompInitialize(' + item + 'Comp, importState=' + item + 'ImportState, &\n')
    fid.write('      exportState=' + item + 'ExportState, clock=parentClock, rc=rc)\n')
    fid.write('    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)\n')

fid.write('''
    call ESMF_LogWrite("toplevel_coupler initialized", ESMF_LOGMSG_INFO)

  end subroutine Initialize

  subroutine Run(gridComp, importState, exportState, parentClock, rc)

    type(ESMF_GridComp)  :: gridComp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: parentClock
    integer, intent(out) :: rc

    character(len=19)       :: timestring
    type(ESMF_Time)         :: clockTime
    type(ESMF_TimeInterval) :: timeInterval
    integer(ESMF_KIND_I8)   :: advanceCount
    
    character(len=ESMF_MAXSTR) :: message

    call ESMF_ClockGet(parentClock,currTime=clockTime, timestep=timeInterval, &
                       advanceCount=advanceCount, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    
    call ESMF_TimeGet(clockTime,timeStringISOFrac=timestring)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    write(message,'(A)') trim(timestring)//' toplevel_coupler run() called.'

    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

    ! From parent clock get current time and time interval, calculate new stop time for local clock as currTime+timeInterval
    call ESMF_ClockSet(clock,stopTime=clockTime + timeInterval, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    do while (.not.ESMF_ClockIsStopTime(clock))

      call ESMF_ClockGet(clock,currTime=clockTime, advanceCount=advanceCount, rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

      call ESMF_TimeGet(clockTime,timeStringISOFrac=timestring)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
       
      call ESMF_ClockAdvance(clock,rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    end do

  end subroutine Run

  subroutine Finalize(gridComp, importState, exportState, parentClock, rc)
    type(ESMF_GridComp)  :: gridComp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: parentClock
    integer, intent(out) :: rc

''')
for item in componentSet:
    fid.write('    call ESMF_GridCompDestroy(' + item + 'Comp, rc=rc)\n')
    fid.write('    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)\n')
for item in couplerSet:
    fid.write('    call ESMF_CplCompDestroy(' + item + 'Comp, rc=rc)\n')
    fid.write('    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)\n')

fid.write('''
    call ESMF_ClockDestroy(clock,rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

  end subroutine Finalize

end module toplevel_coupling
''')

fid.close()

outfilename='Makefile.coupling'
fid = file(outfilename,'w')

fid.write('# This Makefile is part of MOSSCO\n#\n')
fid.write('# Do not edit this file, it is automatically generated by\n')
fid.write('# the call \'python ' + sys.argv[0] + ' ' + filename + '\'\n#\n')
fid.write('# @copyright ' + copyright + '\n')
fid.write('# @author ' + author + '\n')
fid.write('''
#
# MOSSCO is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License v3+.  MOSSCO is distributed in the
# hope that it will be useful, but WITHOUT ANY WARRANTY.  Consult the file
# LICENSE.GPL or www.gnu.org/licenses/gpl-3.0.txt for the full license terms.
#

ifndef MOSSCO_DIR
export MOSSCO_DIR=$(subst /examples/generic$,,$(PWD))
endif

include $(MOSSCO_DIR)/src/Rules.make

''')

# Place conditionals for building this coupled system
conditionals = {'gotm' : 'GOTM', 'fabm' : 'FABM', 'erosed' : 'EROSED', 'fabm_gotm' : 'GOTM_FABM'}
for item in componentSet.union(couplerSet):
    if conditionals.has_key(item):
        fid.write('ifneq ($(MOSSCO_' + conditionals[item] + '),true)\n')
        fid.write('$(error This example only works with MOSSCO_' + conditionals[item] + ' = true)\n')
        fid.write('endif\n')

libs = {'gotm' : ['gotm', 'gotm_prod', 'airsea_prod', 'meanflow_prod', 'seagrass_prod', 'turbulence_prod',
                  'util_prod', 'output_prod', 'observations_prod', 'input_prod'] ,
        'fabm' : ['fabm_prod'],
        'fabm_sediment' : ['sediment', 'mossco_sediment', 'fabm_prod'], 
        'constant' : ['constant'],
        'fabm_gotm' : ['mossco_gotmfabm', 'solver']}

fid.write('\nNC_LIBS += $(shell nf-config --flibs)\n\n')
fid.write('LDFLAGS += $(LIBRARY_PATHS)\n')
for item in componentSet.union(couplerSet):
    if libs.has_key(item):
        fid.write('LDFLAGS +=')
        if item=='gotm':
            fid.write(' -L$(GOTM_LIBRARY_PATH)')
        if item=='getm':
            fid.write(' -L$(GETM_LIBRARY_PATH)')
        if item=='fabm':
            fid.write(' -L$(FABM_LIBRARY_PATH)')
        if item=='fabm_gotm':
            fid.write(' -L$(FABM_LIBRARY_PATH)')
        for lib in libs[item]:
            fid.write(' -l' + lib)
        fid.write('\n')

fid.write('LDFLAGS += $(LIBS) -lmossco_util -lesmf\n\n')
fid.write('.PHONY: all exec\n\n')
fid.write('all: exec\n\n')
fid.write('exec: ' + coupling_name + '\n\n')
fid.write(coupling_name + ': toplevel_coupling.o main.o\n')
fid.write('\t$(F90) $(F90FLAGS) -o $@  $^ $(LDFLAGS)\n')
fid.write('\t@echo "Created example $(MOSSCO_DIR)/examples/$@/$@"\n\n')
fid.write('''

libmossco_gotmfabm libgotm:
	#$(MAKE) -C $(MOSSCO_DIR)/src/components/gotm $@

libmossco_util:
	$(MAKE) -C $(MOSSCO_DIR)/src/utilities $@

libsediment libconstant:
	$(MAKE) -C $(MOSSCO_DIR)/src/components $@

libmossco_sediment libsolver:
	#$(MAKE) -C $(MOSSCO_DIR)/src/drivers $@

libsurfacescoupler:
	$(MAKE) -C $(MOSSCO_DIR)/src/mediators $@

main.o: toplevel_coupling.o main.F90 libmossco_util

toplevel_coupling.o: toplevel_coupling.F90 libmossco_gotmfabm libmossco_util libsediment libmossco_sediment libsolver libconstant libgotm libsurfacescoupler

clean: extraclean
extraclean: 
	@-rm -f coupling main.F90

''')
fid.close()



