!> @brief Implementation of an ESMF component for simplewave
!>
!> Do not edit this file, it is automatically generated!
!>
!> This computer program is part of MOSSCO. 
!> @copyright Copyright 2014, Helmholtz-Zentrum Geesthacht
!> @author Knut Klingbeil, IOW

!
! MOSSCO is free software: you can redistribute it and/or modify it under the
! terms of the GNU General Public License v3+.  MOSSCO is distributed in the
! hope that it will be useful, but WITHOUT ANY WARRANTY.  Consult the file
! LICENSE.GPL or www.gnu.org/licenses/gpl-3.0.txt for the full license terms.
!
module simplewave_component

  use esmf
  use mossco_variable_types


  implicit none
  private

  type(ESMF_Clock)  :: clock 

  public :: SetServices

  real(ESMF_KIND_R8),dimension(:,:,:),allocatable,target,public :: waveH,waveT,waveDir,waveK
  real(ESMF_KIND_R8),parameter :: gravity=9.81d0
  
  contains

  !> Provide an ESMF compliant SetServices routine, which defines
  !! entry points for Init/Run/Finalize
  subroutine SetServices(gridcomp, rc)
  
    type(ESMF_GridComp)  :: gridcomp
    integer, intent(out) :: rc

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_INITIALIZE, Initialize, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_RUN, Run, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_FINALIZE, Finalize, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    rc=ESMF_SUCCESS
    
  end subroutine SetServices

  !> Initialize the component
  !!
  !! Allocate memory, create ESMF fields and add them to export State
  subroutine Initialize(gridComp, importState, exportState, parentClock, rc)
    implicit none

    type(ESMF_GridComp)  :: gridComp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: parentClock
    integer, intent(out) :: rc

    character(len=19) :: timestring
    type(ESMF_Time)   :: clockTime
    type(ESMF_TimeInterval) :: timeInterval
    real(ESMF_KIND_R8) :: dt
    integer                     :: lbnd(3), ubnd(3),farray_shape(3)
    integer                     :: myrank,i,j,k
    integer                     :: nimport,nexport
    type(ESMF_DistGrid)  :: distgrid
    type(ESMF_Grid)      :: grid
    type(ESMF_ArraySpec) :: arrayspec
    type(ESMF_Field)     :: exportField
    
    type(ESMF_Field), dimension(:), allocatable  :: exportFields, importFields
    real(ESMF_KIND_R8), dimension(:,:,:), pointer :: farrayPtr  

    call ESMF_LogWrite("simplewave component initializing ... ",ESMF_LOGMSG_INFO)

    ! Create a local clock, set its parameters to those of the parent clock
    clock = ESMF_ClockCreate(parentClock, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_ClockSet(clock, name='simplewave clock', rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !> @todo
    ! Insert here your initialization code, e.g. fish_init()
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !> Create the grid and coordinates
    !> This example grid is a 1 x 1 x 1 grid, you need to adjust this 
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1,1/),maxIndex=(/1,1,1/), &
      regDecomp=(/1,1,1/),coordSys=ESMF_COORDSYS_SPH_DEG,indexflag=ESMF_INDEX_GLOBAL, &
      name='simplewave grid', rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
   
    ! Get information to generate the fields that store the pointers to variables
    call ESMF_GridGet(grid,distgrid=distgrid,rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    call ESMF_GridGetFieldBounds(grid=grid,localDE=0,staggerloc=ESMF_STAGGERLOC_CENTER,&
      totalCount=farray_shape,rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

!   create export state to be used in toplevel component
    !> Create export fields and add them to export state, allocate the space for these
    !> that will be filled later with data
    nexport = 4
    !allocate(export_variables(nexport)) 

    allocate(waveDir(farray_shape(1),farray_shape(2),farray_shape(3)))
    waveDir = 0.0d0
    allocate(waveH  (farray_shape(1),farray_shape(2),farray_shape(3)))
    waveH = 0.0d0
    allocate(waveT  (farray_shape(1),farray_shape(2),farray_shape(3)))
    waveT = 0.0d0
    allocate(waveK  (farray_shape(1),farray_shape(2),farray_shape(3)))
    waveK = 0.0d0
    
    call ESMF_ArraySpecSet(arrayspec, rank=3, typekind=ESMF_TYPEKIND_R8, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

   !---- Export variable 1: wave_direction
    exportField = ESMF_FieldCreate(grid, waveDir,                     &
                                   indexflag=ESMF_INDEX_GLOBAL,      &
                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
                                   name='wave_direction', rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_StateAddReplace(exportState,(/exportField/),rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    !---- Export variable 2: wave_height
    exportField = ESMF_FieldCreate(grid, waveH,                       &
                                   indexflag=ESMF_INDEX_GLOBAL,      &
                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
                                   name='wave_height', rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_StateAddReplace(exportState,(/exportField/),rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

   !---- Export variable 3: wave_period
    exportField = ESMF_FieldCreate(grid, waveT,                       &
                                   indexflag=ESMF_INDEX_GLOBAL,      &
                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
                                   name='wave_period', rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_StateAddReplace(exportState,(/exportField/),rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

   !---- Export variable 4: wave_number
    exportField = ESMF_FieldCreate(grid, waveK,                       &
                                   indexflag=ESMF_INDEX_GLOBAL,      &
                                   staggerloc=ESMF_STAGGERLOC_CENTER, &
                                   name='wave_number', rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_StateAddReplace(exportState,(/exportField/),rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    call ESMF_LogWrite('simplewave  component initialized.',ESMF_LOGMSG_INFO)
  end subroutine Initialize

  subroutine Run(gridComp, importState, exportState, parentClock, rc)

    type(ESMF_GridComp)  :: gridComp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: parentClock
    integer, intent(out) :: rc

    character(len=19)       :: timestring
    type(ESMF_Time)         :: clockTime
    type(ESMF_TimeInterval) :: timeInterval
    type(ESMF_StateItem_Flag) :: itemType
    integer(ESMF_KIND_I8)   :: n,k
    integer                 :: itemcount,nvar
    real(ESMF_KIND_R8),dimension(:,:,:),pointer :: depth=>null()
    real(ESMF_KIND_R8),dimension(:,:,:),pointer :: wind=>null()
    real(ESMF_KIND_R8),dimension(:,:,:),pointer :: windDir=>null()
    real(ESMF_KIND_R8),dimension(:,:,:),pointer :: windx=>null()
    real(ESMF_KIND_R8),dimension(:,:,:),pointer :: windy=>null()
    real(ESMF_KIND_R8),pointer,dimension(:,:)  :: ptr_f2
    real(ESMF_KIND_R8),pointer,dimension(:,:,:):: ptr_f3
    type(ESMF_Field)        :: Field
    character(len=ESMF_MAXSTR) :: string,varname,message
    real(ESMF_KIND_R8)                :: wdepth,wwind
    real(ESMF_KIND_R8),parameter      :: min_wind=0.1d0
    real(ESMF_KIND_R8),parameter      :: max_depth_windwaves=99999.0
    logical                           :: calc_wind,calc_windDir

    ! associate local pointers with import data
    call ESMF_StateGet(importState, "water_depth", Field, rc=rc)
    if(rc /= ESMF_SUCCESS) then
       call ESMF_LogWrite("water_depth field not found",ESMF_LOGMSG_INFO)
       call ESMF_Finalize(endflag=ESMF_END_ABORT)
    end if
    call ESMF_FieldGet(field, farrayPtr=depth, rc=rc)

    call ESMF_StateGet(importState, "wind_speed", itemType)
    if (itemType .eq. ESMF_STATEITEM_NOTFOUND) then
       calc_wind = .true.
    else
       calc_wind = .false.
       call ESMF_StateGet(importState, "wind_speed", Field)
       call ESMF_FieldGet(field, farrayPtr=wind)
    end if

    call ESMF_StateGet(importState, "wind_direction", itemType)
    if (itemType .eq. ESMF_STATEITEM_NOTFOUND) then
       calc_windDir = .true.
    else
       calc_windDir = .false.
       call ESMF_StateGet(importState, "wind_direction", Field)
       call ESMF_FieldGet(field, farrayPtr=windDir)
    end if

    if (calc_wind .or. calc_windDir) then
       call ESMF_StateGet(importState, "wind_x_velocity_at_10m", Field, rc=rc)
       if (rc /= ESMF_SUCCESS) then
          call ESMF_LogWrite("wind_x_velocity_at_10m field not found",ESMF_LOGMSG_INFO)
          call ESMF_Finalize(endflag=ESMF_END_ABORT)
       end if
       call ESMF_FieldGet(field, farrayPtr=windx, rc=rc)
       call ESMF_StateGet(importState, "wind_y_velocity_at_10m", Field, rc=rc)
       if (rc /= ESMF_SUCCESS) then
          call ESMF_LogWrite("wind_y_velocity_at_10m field not found",ESMF_LOGMSG_INFO)
          call ESMF_Finalize(endflag=ESMF_END_ABORT)
       end if
       call ESMF_FieldGet(field, farrayPtr=windy, rc=rc)
    end if

    if (calc_wind) then
      if (.not. associated(wind)) allocate(wind(1,1,1))
      wind = sqrt(windx**2 + windy**2)
    end if
    if (calc_windDir) then
      if (.not. associated(windDir)) allocate(windDir(1,1,1))
      windDir = atan2(windy,windx) ! cartesian convention and in radians
    end if
   
      waveDir = windDir
      wwind = max( min_wind , wind(1,1,1) )
      wdepth = min( depth(1,1,1) , max_depth_windwaves )
      waveH(1,1,1) = wind2waveHeight(wwind,wdepth)
      waveT(1,1,1) = wind2wavePeriod(wwind,wdepth)
      waveK(1,1,1) = wavePeriod2waveNumber(waveT(1,1,1),depth(1,1,1))
 
  end subroutine Run

  subroutine Finalize(gridComp, importState, exportState, parentClock, rc)
    type(ESMF_GridComp)  :: gridComp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: parentClock
    integer, intent(out) :: rc

    integer                     :: lbnd(3), ubnd(3), k
    real(ESMF_KIND_R8),pointer :: farrayPtr(:,:,:)
    type(ESMF_Field)     :: field

!    do k=1,size(export_variables)
!      call ESMF_StateGet(exportState,trim(export_variables(k)%standard_name), field, rc=rc)
!      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

!#if ESMF_VERSION_MAJOR > 5
!      call ESMF_StateRemove(exportState,(/ trim(export_variables(k)%standard_name) /),rc=rc)
!#else
!      call ESMF_StateRemove(exportState,trim(export_variables(k)%standard_name),rc=rc)
!#endif
!      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

!      call ESMF_FieldDestroy(field, rc=rc)
!      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
!    enddo

    call ESMF_ClockDestroy(clock,rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !> @todo 
    ! Insert here your finalization code
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  end subroutine Finalize
!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: wind2waveHeight - estimates significant wave height from wind
!
! !INTERFACE:
   real(ESMF_KIND_R8) function wind2waveHeight(wind,depth)

! !USES:
   IMPLICIT NONE
!
! !INPUT PARAMETERS:
   real(ESMF_KIND_R8),intent(in) :: wind,depth
!
! !DESCRIPTION:
!  Calculates significant wave height (Hm0) under assumption of unlimited fetch.
!  See page 250 in Holthuijsen (2007).
!
! !REVISION HISTORY:
!  Original author(s): Ulf Graewe
!                      Knut Klingbeil
!
! !LOCAL VARIABLES
   real(ESMF_KIND_R8)           :: depthstar,waveHeightstar
   real(ESMF_KIND_R8),parameter :: waveHeightstar8 = 0.24d0
   real(ESMF_KIND_R8),parameter :: k3 = 0.343d0
   real(ESMF_KIND_R8),parameter :: m3 = 1.14d0
   real(ESMF_KIND_R8),parameter :: p  = 0.572d0
!
!EOP
!-----------------------------------------------------------------------
!BOC

!  dimensionless depth
   depthstar = gravity * depth / wind**2

!  dimensionless significant wave height
   waveHeightstar = waveHeightstar8 * tanh(k3*depthstar**m3)**p

!  significant wave height
   wind2waveHeight = wind**2 * waveHeightstar / gravity

   end function wind2waveHeight
!EOC
!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: wind2wavePeriod - estimates peak wave period from wind
!
! !INTERFACE:
   real(ESMF_KIND_R8) function wind2wavePeriod(wind,depth)

! !USES:
   IMPLICIT NONE
!
! !INPUT PARAMETERS:
   real(ESMF_KIND_R8),intent(in) :: wind,depth
!
! !DESCRIPTION:
!  Calculates peak wave period under assumption of unlimited fetch.
!  See page 250 in Holthuijsen (2007).
!  The peak wave period can be empirically related to the significant
!  wave period (Holthuijsen Eqs. (4.2.7) and (4.2.9)).
!
! !REVISION HISTORY:
!  Original author(s): Ulf Graewe
!                      Knut Klingbeil
!
! !LOCAL VARIABLES
   real(ESMF_KIND_R8)           :: depthstar,wavePeriodstar
   real(ESMF_KIND_R8),parameter :: wavePeriodstar8 = 7.69d0
   real(ESMF_KIND_R8),parameter :: k4 = 0.10d0
   real(ESMF_KIND_R8),parameter :: m4 = 2.01d0
   real(ESMF_KIND_R8),parameter :: q  = 0.187d0
!
!EOP
!-----------------------------------------------------------------------
!BOC

!  dimensionless depth
   depthstar = gravity * depth / wind**2

!  dimensionless peak wave period
   wavePeriodstar = wavePeriodstar8 * tanh(k4*depthstar**m4)**q

!  peak wave period
   wind2wavePeriod = wind * wavePeriodstar / gravity

   end function wind2wavePeriod
!EOC
!-----------------------------------------------------------------------
!BOP
!
! !IROUTINE: wavePeriod2waveNumber - approximates wave number from wave period
!
! !INTERFACE:
   real(ESMF_KIND_R8) function wavePeriod2waveNumber(period,depth)

! !USES:
   IMPLICIT NONE
!
! !INPUT PARAMETERS:
   real(ESMF_KIND_R8),intent(in) :: period,depth
!
! !DESCRIPTION:
!  x=k*D=kD,y=omega/sqrt(g/D)=omegastar
!  y=sqrt(x*tanh(x)),y(1)=0.8727=omegastar1
!  x'=lg(x),(dx'|dx)=1/(x*ln(10))
!  y'=lg(y),(dy'|dy)=1/(y*ln(10))
!  m'(x)=(dy'|dx')=(dy'|dy)*(dy|dx)*(dx|dx')=x/y*m(x)
!  m(x)=(dy|dx)=0.5*[tanh(x)+x*(1-tanh(x)**2)]/sqrt(x*tanh(x))
!  m(1)=0.677,m'(1)=0.77572=slopestar1
!  y'=lg(y(1))+m'(1)*x' <=> y=y(1)*[x**m'(1)] <=> x=(y/y(1))**(1/m'(1))
!  shallow: y=x       => x<=y(1)**(1/(1  -m'(1)))=0.5449  => y<=0.5449
!  deep   : y=sqrt(x) => x>=y(1)**(1/(0.5-m'(1)))=1.63865 => y>=1.28
!
!  For alternatives see Holthuijsen (2007) page 124
!  (Eckart, 1952 and Fenton, 1988)
!
! !REVISION HISTORY:
!  Original author(s): Knut Klingbeil
!
! !LOCAL VARIABLES
   real(ESMF_KIND_R8)           :: omega,omegastar,kD
   real(ESMF_KIND_R8),parameter :: omegastar1_rec = 1.0d0/0.8727d0
   real(ESMF_KIND_R8),parameter :: slopestar1_rec = 1.0d0/0.77572d0
   real(ESMF_KIND_R8),parameter :: one5th = 1.0d0/5
   real(ESMF_KIND_R8),parameter :: pi=3.1415926535897932384626433832795029d0
!
!EOP
!-----------------------------------------------------------------------
!BOC
 
   omega = 2 * pi / period ! radian frequency
   omegastar = omega * sqrt(depth/gravity) ! non-dimensional radian frequency

!!   approximation by Knut
!!   (errors less than 5%)
!   if ( omegastar .gt. 1.28d0 ) then
!!     deep-water approximation
!      kD = omegastar**2
!   else if ( omegastar .lt. 0.5449d0 ) then
!!     shallow-water approximation
!      kD = omegastar
!   else
!!     tangential approximation in loglog-space for full dispersion relation
!      kD = (omegastar1_rec * omegastar) ** slopestar1_rec
!   end if

!  approximation by Soulsby (1997, page 71) (see (18) in Lettmann et al., 2009)
!  (errors less than 1%)
   if ( omegastar .gt. 1.0d0 ) then
      kD = omegastar**2 * ( 1.0d0 + one5th*exp(2*(1.0d0-omegastar**2)) )
   else
      kD = omegastar * ( 1.0d0 + one5th*omegastar**2 )
   end if

   wavePeriod2waveNumber = kD / depth

   end function wavePeriod2waveNumber
!EOC
!-----------------------------------------------------------------------
end module simplewave_component
