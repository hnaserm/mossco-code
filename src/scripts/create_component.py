import yaml
import sys
import os

if len(sys.argv) > 1:
    filename = sys.argv[1]
else:
    filename = 'fish_component.yaml'

print sys.argv, len(sys.argv)
if not os.path.exists(filename):
    print 'File ' + filename + ' does not exist.'
   
print 'Using ' + filename + ' ...' 

fid = file(filename,'rU')
config = yaml.load(fid)
fid.close()

# Search for the key with name "component".  If part of the filename is the word "component" then assume that the first item on the list read is the name of the component
component_name = 'unknown'
variables = []
component_properties = []

if config.has_key('author'):
    author = config.pop('author')
else:
    author = 'Carsten Lemmen, <carsten.lemmen@hzg.de>'

if config.has_key('copyright'):
    copyright = config.pop('copyright')
else:
    copyright = 'Copyright (C) 2014, Helmholtz-Zentrum Geesthacht'

if config.has_key('component'):
  component = config.pop('component')
else:
  component=config.values()[0]
  component_name=config.keys()[0]
 
if component.has_key('short_name'):
  component_name=component.pop('short_name')
  
if component.has_key('grid'):
  grid=component.pop('grid')
  
for key, value in component.items():
    if type(value) is dict:
        variables.append({key : value})
        component.pop(key)
    else:
        component_properties.append({key : value})

import_variables=[]
export_variables=[]
module_list=[]
for item in variables:
  if item.values()[0].has_key('intent'):
    if item.values()[0]['intent']=='import' or item.values()[0]['intent']=='in': 
      import_variables.append(item)
    elif item.values()[0]['intent']=='both' or item.values()[0]['intent']=='inout':
      import_variables.append(item)
      export_variables.append(item)
    else:
      export_variables.append(item)
  else:
      export_variables.append(item)      
  if item.values()[0].has_key('module'):
    if item.values()[0].has_key('internal_name'):
      module_list.append('  use ' + item.values()[0]['module'] + ', only : ' 
                         + item.values()[0]['internal_name'])
       
filename = component_name + '_component.F90'
fid = file(filename,'w')

fid.write('!> @brief Implementation of an ESMF component for ' + component_name)
fid.write('''
!>
!> Do not edit this file, it is automatically generated!
!>
!> This computer program is part of MOSSCO. 
''')
fid.write('!> @copyright ' + copyright + '\n')
fid.write('!> @author ' + author + '\n')
fid.write('''
!
! MOSSCO is free software: you can redistribute it and/or modify it under the
! terms of the GNU General Public License v3+.  MOSSCO is distributed in the
! hope that it will be useful, but WITHOUT ANY WARRANTY.  Consult the file
! LICENSE.GPL or www.gnu.org/licenses/gpl-3.0.txt for the full license terms.
!
''')

fid.write('module ' + component_name + '_component\n') 
fid.write('''
  use esmf
  use mossco_variable_types\n
''')

for line in module_list:
    fid.write(line + '\n')

fid.write('\n  implicit none\n  private\n')
fid.write('''
  type(ESMF_Clock)  :: clock 
  real(ESMF_KIND_R8), allocatable, target :: variables(:,:,:,:)
''')

fid.write('''
  public :: SetServices
  
  contains

  !> Provide an ESMF compliant SetServices routine, which defines
  !! entry points for Init/Run/Finalize
  subroutine SetServices(gridcomp, rc)
  
    type(ESMF_GridComp)  :: gridcomp
    integer, intent(out) :: rc

    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_INITIALIZE, Initialize, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_RUN, Run, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    call ESMF_GridCompSetEntryPoint(gridcomp, ESMF_METHOD_FINALIZE, Finalize, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    rc=ESMF_SUCCESS
    
  end subroutine SetServices

  !> Initialize the component
  !!
  !! Allocate memory, create ESMF fields and add them to export State
  subroutine Initialize(gridComp, importState, exportState, parentClock, rc)
    implicit none

    type(ESMF_GridComp)  :: gridComp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: parentClock
    integer, intent(out) :: rc

    character(len=19) :: timestring
    type(ESMF_Time)   :: clockTime
    type(ESMF_TimeInterval) :: timeInterval
    real(ESMF_KIND_R8) :: dt
    integer                     :: lbnd(3), ubnd(3),farray_shape(3)
    integer                     :: myrank,i,j,k
    integer                     :: nimport,nexport
    type(ESMF_DistGrid)  :: distgrid
    type(ESMF_Grid)      :: grid
    type(ESMF_ArraySpec) :: arrayspec
    
    type(ESMF_Field), dimension(:), allocatable  :: exportFields, importFields
    real(ESMF_KIND_R8), dimension(:,:,:), pointer :: farrayPtr  

    ! Create a local clock, set its parameters to those of the parent clock
    clock = ESMF_ClockCreate(parentClock, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
''')

fid.write('    call ESMF_ClockSet(clock, name=\'' + component_name + ' clock\', rc=rc)')
fid.write('''
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
''')

fid.write('''
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !> @todo
    ! Insert here your initialization code, e.g. fish_init()
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
''')

fid.write('''
    !> Create the grid and coordinates
    !> This example grid is a 1 x 1 x 1 grid, you need to adjust this 
    grid = ESMF_GridCreateNoPeriDim(minIndex=(/1,1,1/),maxIndex=(/1,1,1/), &
      regDecomp=(/1,1,1/),coordSys=ESMF_COORDSYS_SPH_DEG,indexflag=ESMF_INDEX_GLOBAL, &
''')
fid.write('      name=\'' + component_name + ' grid\', rc=rc)')
fid.write('''
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
   
    ! Get information to generate the fields that store the pointers to variables
    call ESMF_GridGet(grid,distgrid=distgrid,rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    call ESMF_GridGetFieldBounds(grid=grid,localDE=0,staggerloc=ESMF_STAGGERLOC_CENTER,&
      totalCount=farray_shape,rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    !> Create export fields and add them to export state, allocate the space for these
    !> that will be filled later with data
''')

nexport = len(export_variables)
if nexport > 0:
    fid.write('    nexport = ' + str(nexport))
    fid.write('''
    !allocate(export_variables(nexport)) 
    allocate(variables(farray_shape(1),farray_shape(2),farray_shape(3),nexport))
    
    call ESMF_ArraySpecSet(arrayspec, rank=3, typekind=ESMF_TYPEKIND_R8, rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)\n
 ''')
    for k in range(nexport):
        if variables[k].values()[0].has_key('standard_name'): 
            variable_name = variables[k].values()[0]['standard_name']
        else:
            variable_name = variables[k].keys()[0]
        fid.write('   !---- Export variable ' + str(k+1) + ': ' + variable_name + '\n')
        fid.write('    exportField = ESMF_FieldCreate(grid, arrayspec, staggerloc=ESMF_STAGGERLOC_CENTER, &\n')
        fid.write('      name=\'' + variable_name + '\', rc=rc)')
        fid.write('''
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    call ESMF_StateAddReplace(exportState,(/exportField/),rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    call ESMF_FieldGet(field=exportField, localDe=0, farrayPtr=farrayPtr, &
                       totalLBound=lbnd,totalUBound=ubnd, rc=rc) 
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

''')           
        if variables[k].values()[0].has_key('internal_name'): 
            if variables[k].values()[0].has_key('default_value'): 
                fid.write('    ' + variables[k].values()[0]['internal_name'] + ' =  ' 
                      + str(variables[k].values()[0]['default_value']) + '\n')
            fid.write('    variables(:,:,:,' + str(k+1) + ') =  ' 
                     + variables[k].values()[0]['internal_name'] + '\n')
        elif variables[k].values()[0].has_key('default_value'): 
            fid.write('    variables(:,:,:,' + str(k+1) + ') =  ' 
                      + str(variables[k].values()[0]['default_value']) + '\n')              
        fid.write('    farrayPtr=variables(:,:,:,' + str(k+1) + ')\n\n')        
    fid.write('    call ESMF_LogWrite(\'' + component_name + '  component initialized.\',ESMF_LOGMSG_INFO)')
    fid.write('''
  end subroutine Initialize

  subroutine Run(gridComp, importState, exportState, parentClock, rc)

    type(ESMF_GridComp)  :: gridComp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: parentClock
    integer, intent(out) :: rc

    character(len=19)       :: timestring
    type(ESMF_Time)         :: clockTime
    type(ESMF_TimeInterval) :: timeInterval
    integer(ESMF_KIND_I8)   :: n,k
    integer                 :: itemcount,nvar
    real(ESMF_KIND_R8),pointer,dimension(:,:)  :: ptr_f2
    real(ESMF_KIND_R8),pointer,dimension(:,:,:):: ptr_f3
    type(ESMF_Field)        :: Field
    character(len=ESMF_MAXSTR) :: string,varname,message

    call ESMF_ClockGet(parentClock,currTime=clockTime, timestep=timeInterval, &
                       advanceCount=n, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    
    call ESMF_TimeGet(clockTime,timeStringISOFrac=timestring)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
''')
    
    fid.write('    write(message,\'(A)\') trim(timestring)//\' ' + component_name + ' run() called.\'')
    fid.write('''
    call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

    ! From parent clock get current time and time interval, calculate new stop time for local clock as currTime+timeInterval
    call ESMF_ClockSet(clock,stopTime=clockTime + timeInterval, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! Get the import states and map to local variables
 ''')   
#       call ESMF_StateGet(fabmImp,'hzg_omexdia_p dissolved phosphate',field,rc=rc)
#      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
#      call ESMF_FieldGet(field,localde=0,farrayPtr=ptr_f3,rc=rc)
#      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
#      ptr_f3(1,1,1) = 1.0d0/16.0d0 * val1_f3(1,1,1)
 
    fid.write('''  
    do while (.not.ESMF_ClockIsStopTime(clock))

      call ESMF_ClockGet(clock,currTime=clockTime, advanceCount=n, rc=rc)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

      call ESMF_TimeGet(clockTime,timeStringISOFrac=timestring)
      if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
      
''')
    fid.write('      write(message,\'(A,I5)\') trim(timestring)//\' ' + component_name + ' iteration \', n')
    fid.write('''
      call ESMF_LogWrite(trim(message), ESMF_LOGMSG_INFO)

      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      !> @todo 
      ! Insert here your time step/run code
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

''')
    for k in range(nexport):
      fid.write('      variables(:,:,:,' + str(k+1) + ') = internal_name\n')
    fid.write('''       
 
      call ESMF_ClockAdvance(clock,rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
    end do

  end subroutine Run

  subroutine Finalize(gridComp, importState, exportState, parentClock, rc)
    type(ESMF_GridComp)  :: gridComp
    type(ESMF_State)     :: importState, exportState
    type(ESMF_Clock)     :: parentClock
    integer, intent(out) :: rc

    integer                     :: lbnd(3), ubnd(3), k
    real(ESMF_KIND_R8),pointer :: farrayPtr(:,:,:)
    type(ESMF_Field)     :: field

    do k=1,size(export_variables)
      call ESMF_StateGet(exportState,trim(export_variables(k)%standard_name), field, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

#if ESMF_VERSION_MAJOR > 5
      call ESMF_StateRemove(exportState,(/ trim(export_variables(k)%standard_name) /),rc=rc)
#else
      call ESMF_StateRemove(exportState,trim(export_variables(k)%standard_name),rc=rc)
#endif
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

      call ESMF_FieldDestroy(field, rc=rc)
      if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)
    enddo

    if (allocated(variables)) deallocate(variables)

    call ESMF_ClockDestroy(clock,rc=rc)
    if(rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT, rc=rc)

    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    !> @todo 
    ! Insert here your finalization code
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  end subroutine Finalize
''')


fid.write('end module ' + component_name + '_component') 
fid.close()

